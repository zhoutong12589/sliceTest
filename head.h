// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `head.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __head_h__
#define __head_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/SliceChecksumDict.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace modes
{

class actions;
class actionsPrx;
class base;
class stu;
class getAction;
class getActionPrx;

}

namespace modes
{

struct node
{
    int n1;
    int n2;

    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(n1, n2);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace modes
{

class actions : public virtual ::Ice::Object
{
public:

    using ProxyType = actionsPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual void printString(::std::string, const ::Ice::Current&) = 0;
    bool _iceD_printString(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual int printStringWithRet(::std::string, const ::Ice::Current&) = 0;
    bool _iceD_printStringWithRet(::IceInternal::Incoming&, const ::Ice::Current&);

    struct GetnumResult
    {
        bool returnValue;
        int num;
    };

    virtual bool getnum(int, int, int&, const ::Ice::Current&) = 0;
    bool _iceD_getnum(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void computeAsync(int, int, ::std::function<void(int)>, ::std::function<void(::std::exception_ptr)>, const ::Ice::Current&) = 0;
    bool _iceD_compute(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

class getAction : public virtual ::Ice::Object
{
public:

    using ProxyType = getActionPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<::modes::actionsPrx> getactions(const ::Ice::Current&) = 0;
    bool _iceD_getactions(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::shared_ptr<::modes::stu> getStu(::std::shared_ptr<::modes::stu>, const ::Ice::Current&) = 0;
    bool _iceD_getStu(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::modes::node getNode(::modes::node, const ::Ice::Current&) = 0;
    bool _iceD_getNode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::SliceChecksumDict getChecksums(const ::Ice::Current&) = 0;
    bool _iceD_getChecksums(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

}

namespace modes
{

class base : public ::Ice::ValueHelper<base, Ice::Value>
{
public:

    virtual ~base();

    base() = default;

    base(const base&) = default;
    base(base&&) = default;
    base& operator=(const base&) = default;
    base& operator=(base&&) = default;

    explicit base(int iceP_name) :
        name(iceP_name)
    {
    }

    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(name);
    }

    static const ::std::string& ice_staticId();

    int name;
};

static base _iceS_base_init;

class stu : public ::Ice::ValueHelper<stu, ::modes::base>
{
public:

    virtual ~stu();

    stu() = default;

    stu(const stu&) = default;
    stu(stu&&) = default;
    stu& operator=(const stu&) = default;
    stu& operator=(stu&&) = default;

    stu(int iceP_name, int iceP_num) :
        Ice::ValueHelper<::modes::stu, ::modes::base>(iceP_name),
        num(iceP_num)
    {
    }

    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(name, num);
    }

    static const ::std::string& ice_staticId();

    int num;
};

}

namespace modes
{

class actionsPrx : public virtual ::Ice::Proxy<actionsPrx, ::Ice::ObjectPrx>
{
public:

    void printString(const ::std::string& iceP_str, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &modes::actionsPrx::_iceI_printString, iceP_str, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto printStringAsync(const ::std::string& iceP_str, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &modes::actionsPrx::_iceI_printString, iceP_str, context);
    }

    ::std::function<void()>
    printStringAsync(const ::std::string& iceP_str,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &modes::actionsPrx::_iceI_printString, iceP_str, context);
    }

    void _iceI_printString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);

    int printStringWithRet(const ::std::string& iceP_str, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &modes::actionsPrx::_iceI_printStringWithRet, iceP_str, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto printStringWithRetAsync(const ::std::string& iceP_str, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &modes::actionsPrx::_iceI_printStringWithRet, iceP_str, context);
    }

    ::std::function<void()>
    printStringWithRetAsync(const ::std::string& iceP_str,
                            ::std::function<void(int)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(response, ex, sent, this, &modes::actionsPrx::_iceI_printStringWithRet, iceP_str, context);
    }

    void _iceI_printStringWithRet(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::std::string&, const ::Ice::Context&);

    bool getnum(int iceP_n1, int iceP_n2, int& iceP_num, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        auto result = _makePromiseOutgoing<::modes::actions::GetnumResult>(true, this, &modes::actionsPrx::_iceI_getnum, iceP_n1, iceP_n2, context).get();
        iceP_num = result.num;
        return result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getnumAsync(int iceP_n1, int iceP_n2, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::modes::actions::GetnumResult>>().get_future())
    {
        return _makePromiseOutgoing<::modes::actions::GetnumResult, P>(false, this, &modes::actionsPrx::_iceI_getnum, iceP_n1, iceP_n2, context);
    }

    ::std::function<void()>
    getnumAsync(int iceP_n1, int iceP_n2,
                ::std::function<void(bool, int)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = Ice::noExplicitContext)
    {
        auto responseCb = [response](::modes::actions::GetnumResult&& result)
        {
            response(result.returnValue, result.num);
        };
        return _makeLamdaOutgoing<::modes::actions::GetnumResult>(responseCb, ex, sent, this, &modes::actionsPrx::_iceI_getnum, iceP_n1, iceP_n2, context);
    }

    void _iceI_getnum(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::modes::actions::GetnumResult>>&, int, int, const ::Ice::Context&);

    int compute(int iceP_n1, int iceP_n2, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &modes::actionsPrx::_iceI_compute, iceP_n1, iceP_n2, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto computeAsync(int iceP_n1, int iceP_n2, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &modes::actionsPrx::_iceI_compute, iceP_n1, iceP_n2, context);
    }

    ::std::function<void()>
    computeAsync(int iceP_n1, int iceP_n2,
                 ::std::function<void(int)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(response, ex, sent, this, &modes::actionsPrx::_iceI_compute, iceP_n1, iceP_n2, context);
    }

    void _iceI_compute(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, int, int, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    actionsPrx() = default;
    friend ::std::shared_ptr<actionsPrx> IceInternal::createProxy<actionsPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class getActionPrx : public virtual ::Ice::Proxy<getActionPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<::modes::actionsPrx> getactions(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::modes::actionsPrx>>(true, this, &modes::getActionPrx::_iceI_getactions, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getactionsAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::modes::actionsPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::modes::actionsPrx>, P>(false, this, &modes::getActionPrx::_iceI_getactions, context);
    }

    ::std::function<void()>
    getactionsAsync(::std::function<void(::std::shared_ptr<::modes::actionsPrx>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::modes::actionsPrx>>(response, ex, sent, this, &modes::getActionPrx::_iceI_getactions, context);
    }

    void _iceI_getactions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::modes::actionsPrx>>>&, const ::Ice::Context&);

    ::std::shared_ptr<::modes::stu> getStu(const ::std::shared_ptr<::modes::stu>& iceP_s, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::modes::stu>>(true, this, &modes::getActionPrx::_iceI_getStu, iceP_s, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getStuAsync(const ::std::shared_ptr<::modes::stu>& iceP_s, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::modes::stu>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::modes::stu>, P>(false, this, &modes::getActionPrx::_iceI_getStu, iceP_s, context);
    }

    ::std::function<void()>
    getStuAsync(const ::std::shared_ptr<::modes::stu>& iceP_s,
                ::std::function<void(::std::shared_ptr<::modes::stu>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::modes::stu>>(response, ex, sent, this, &modes::getActionPrx::_iceI_getStu, iceP_s, context);
    }

    void _iceI_getStu(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::modes::stu>>>&, const ::std::shared_ptr<::modes::stu>&, const ::Ice::Context&);

    ::modes::node getNode(const ::modes::node& iceP_n, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::modes::node>(true, this, &modes::getActionPrx::_iceI_getNode, iceP_n, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNodeAsync(const ::modes::node& iceP_n, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::modes::node>>().get_future())
    {
        return _makePromiseOutgoing<::modes::node, P>(false, this, &modes::getActionPrx::_iceI_getNode, iceP_n, context);
    }

    ::std::function<void()>
    getNodeAsync(const ::modes::node& iceP_n,
                 ::std::function<void(::modes::node)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::modes::node>(response, ex, sent, this, &modes::getActionPrx::_iceI_getNode, iceP_n, context);
    }

    void _iceI_getNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::modes::node>>&, const ::modes::node&, const ::Ice::Context&);

    ::Ice::SliceChecksumDict getChecksums(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Ice::SliceChecksumDict>(true, this, &modes::getActionPrx::_iceI_getChecksums, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getChecksumsAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Ice::SliceChecksumDict>>().get_future())
    {
        return _makePromiseOutgoing<::Ice::SliceChecksumDict, P>(false, this, &modes::getActionPrx::_iceI_getChecksums, context);
    }

    ::std::function<void()>
    getChecksumsAsync(::std::function<void(::Ice::SliceChecksumDict)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Ice::SliceChecksumDict>(response, ex, sent, this, &modes::getActionPrx::_iceI_getChecksums, context);
    }

    void _iceI_getChecksums(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::SliceChecksumDict>>&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    getActionPrx() = default;
    friend ::std::shared_ptr<getActionPrx> IceInternal::createProxy<getActionPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

}

namespace Ice
{

template<typename S>
struct StreamReader<::modes::base, S>
{
    static void read(S* istr, ::modes::base& v)
    {
        istr->readAll(v.name);
    }
};

template<typename S>
struct StreamWriter<::modes::stu, S>
{
    static void write(S* ostr, const ::modes::stu& v)
    {
        ostr->writeAll(v.num);
    }
};

template<typename S>
struct StreamReader<::modes::stu, S>
{
    static void read(S* istr, ::modes::stu& v)
    {
        istr->readAll(v.num);
    }
};

template<>
struct StreamableTraits<::modes::node>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::modes::node, S>
{
    static void read(S* istr, ::modes::node& v)
    {
        istr->readAll(v.n1, v.n2);
    }
};

}

namespace modes
{

using actionsPtr = ::std::shared_ptr<actions>;
using actionsPrxPtr = ::std::shared_ptr<actionsPrx>;

using basePtr = ::std::shared_ptr<base>;

using stuPtr = ::std::shared_ptr<stu>;

using getActionPtr = ::std::shared_ptr<getAction>;
using getActionPrxPtr = ::std::shared_ptr<getActionPrx>;

}

#else // C++98 mapping

namespace IceProxy
{

namespace modes
{

class actions;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::modes::actions>&);
::IceProxy::Ice::Object* upCast(::IceProxy::modes::actions*);

class base;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::modes::base>&);
::IceProxy::Ice::Object* upCast(::IceProxy::modes::base*);

class stu;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::modes::stu>&);
::IceProxy::Ice::Object* upCast(::IceProxy::modes::stu*);

class getAction;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::modes::getAction>&);
::IceProxy::Ice::Object* upCast(::IceProxy::modes::getAction*);

}

}

namespace modes
{

class actions;
::Ice::Object* upCast(::modes::actions*);
typedef ::IceInternal::Handle< ::modes::actions> actionsPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::modes::actions> actionsPrx;
typedef actionsPrx actionsPrxPtr;
void _icePatchObjectPtr(actionsPtr&, const ::Ice::ObjectPtr&);

class base;
::Ice::Object* upCast(::modes::base*);
typedef ::IceInternal::Handle< ::modes::base> basePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::modes::base> basePrx;
typedef basePrx basePrxPtr;
void _icePatchObjectPtr(basePtr&, const ::Ice::ObjectPtr&);

class stu;
::Ice::Object* upCast(::modes::stu*);
typedef ::IceInternal::Handle< ::modes::stu> stuPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::modes::stu> stuPrx;
typedef stuPrx stuPrxPtr;
void _icePatchObjectPtr(stuPtr&, const ::Ice::ObjectPtr&);

class getAction;
::Ice::Object* upCast(::modes::getAction*);
typedef ::IceInternal::Handle< ::modes::getAction> getActionPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::modes::getAction> getActionPrx;
typedef getActionPrx getActionPrxPtr;
void _icePatchObjectPtr(getActionPtr&, const ::Ice::ObjectPtr&);

}

namespace modes
{

struct node
{
    ::Ice::Int n1;
    ::Ice::Int n2;

    bool operator==(const node& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(n1 != rhs_.n1)
        {
            return false;
        }
        if(n2 != rhs_.n2)
        {
            return false;
        }
        return true;
    }

    bool operator<(const node& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(n1 < rhs_.n1)
        {
            return true;
        }
        else if(rhs_.n1 < n1)
        {
            return false;
        }
        if(n2 < rhs_.n2)
        {
            return true;
        }
        else if(rhs_.n2 < n2)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const node& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const node& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const node& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const node& rhs_) const
    {
        return !operator<(rhs_);
    }
};

}

namespace modes
{

class AMD_actions_compute : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_actions_compute();

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::modes::AMD_actions_compute> AMD_actions_computePtr;

}

namespace IceAsync
{

namespace modes
{

class AMD_actions_compute : public ::modes::AMD_actions_compute, public ::IceInternal::IncomingAsync
{
public:

    AMD_actions_compute(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
};

}

}

namespace modes
{

class Callback_actions_printString_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_actions_printString_Base> Callback_actions_printStringPtr;

class Callback_actions_printStringWithRet_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_actions_printStringWithRet_Base> Callback_actions_printStringWithRetPtr;

class Callback_actions_getnum_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_actions_getnum_Base> Callback_actions_getnumPtr;

class Callback_actions_compute_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_actions_compute_Base> Callback_actions_computePtr;

class Callback_getAction_getactions_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_getAction_getactions_Base> Callback_getAction_getactionsPtr;

class Callback_getAction_getStu_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_getAction_getStu_Base> Callback_getAction_getStuPtr;

class Callback_getAction_getNode_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_getAction_getNode_Base> Callback_getAction_getNodePtr;

class Callback_getAction_getChecksums_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_getAction_getChecksums_Base> Callback_getAction_getChecksumsPtr;

}

namespace IceProxy
{

namespace modes
{

class actions : public virtual ::Ice::Proxy<actions, ::IceProxy::Ice::Object>
{
public:

    void printString(const ::std::string& iceP_str, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_printString(_iceI_begin_printString(iceP_str, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_printString(const ::std::string& iceP_str, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_printString(iceP_str, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_printString(const ::std::string& iceP_str, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printString(iceP_str, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_printString(const ::std::string& iceP_str, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printString(iceP_str, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_printString(const ::std::string& iceP_str, const ::modes::Callback_actions_printStringPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printString(iceP_str, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_printString(const ::std::string& iceP_str, const ::Ice::Context& context, const ::modes::Callback_actions_printStringPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printString(iceP_str, context, del, cookie);
    }

    void end_printString(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_printString(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int printStringWithRet(const ::std::string& iceP_str, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_printStringWithRet(_iceI_begin_printStringWithRet(iceP_str, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_printStringWithRet(const ::std::string& iceP_str, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_printStringWithRet(iceP_str, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_printStringWithRet(const ::std::string& iceP_str, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printStringWithRet(iceP_str, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_printStringWithRet(const ::std::string& iceP_str, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printStringWithRet(iceP_str, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_printStringWithRet(const ::std::string& iceP_str, const ::modes::Callback_actions_printStringWithRetPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printStringWithRet(iceP_str, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_printStringWithRet(const ::std::string& iceP_str, const ::Ice::Context& context, const ::modes::Callback_actions_printStringWithRetPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_printStringWithRet(iceP_str, context, del, cookie);
    }

    ::Ice::Int end_printStringWithRet(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_printStringWithRet(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool getnum(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, ::Ice::Int& iceP_num, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getnum(iceP_num, _iceI_begin_getnum(iceP_n1, iceP_n2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getnum(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getnum(iceP_n1, iceP_n2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getnum(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getnum(iceP_n1, iceP_n2, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getnum(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getnum(iceP_n1, iceP_n2, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getnum(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::modes::Callback_actions_getnumPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getnum(iceP_n1, iceP_n2, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getnum(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::Ice::Context& context, const ::modes::Callback_actions_getnumPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getnum(iceP_n1, iceP_n2, context, del, cookie);
    }

    bool end_getnum(::Ice::Int& iceP_num, const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getnum(::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int compute(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_compute(_iceI_begin_compute(iceP_n1, iceP_n2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_compute(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_compute(iceP_n1, iceP_n2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_compute(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_compute(iceP_n1, iceP_n2, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_compute(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_compute(iceP_n1, iceP_n2, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_compute(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::modes::Callback_actions_computePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_compute(iceP_n1, iceP_n2, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_compute(::Ice::Int iceP_n1, ::Ice::Int iceP_n2, const ::Ice::Context& context, const ::modes::Callback_actions_computePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_compute(iceP_n1, iceP_n2, context, del, cookie);
    }

    ::Ice::Int end_compute(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_compute(::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class base : public virtual ::Ice::Proxy<base, ::IceProxy::Ice::Object>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class stu : public virtual ::Ice::Proxy<stu, ::IceProxy::modes::base>
{
public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class getAction : public virtual ::Ice::Proxy<getAction, ::IceProxy::Ice::Object>
{
public:

    ::modes::actionsPrx getactions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getactions(_iceI_begin_getactions(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getactions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getactions(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getactions(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getactions(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getactions(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getactions(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getactions(const ::modes::Callback_getAction_getactionsPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getactions(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getactions(const ::Ice::Context& context, const ::modes::Callback_getAction_getactionsPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getactions(context, del, cookie);
    }

    ::modes::actionsPrx end_getactions(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getactions(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::modes::stuPtr getStu(const ::modes::stuPtr& iceP_s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getStu(_iceI_begin_getStu(iceP_s, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getStu(const ::modes::stuPtr& iceP_s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getStu(iceP_s, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStu(const ::modes::stuPtr& iceP_s, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStu(iceP_s, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStu(const ::modes::stuPtr& iceP_s, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStu(iceP_s, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStu(const ::modes::stuPtr& iceP_s, const ::modes::Callback_getAction_getStuPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStu(iceP_s, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStu(const ::modes::stuPtr& iceP_s, const ::Ice::Context& context, const ::modes::Callback_getAction_getStuPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStu(iceP_s, context, del, cookie);
    }

    ::modes::stuPtr end_getStu(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getStu(const ::modes::stuPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::modes::node getNode(const ::modes::node& iceP_n, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getNode(_iceI_begin_getNode(iceP_n, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getNode(const ::modes::node& iceP_n, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getNode(iceP_n, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNode(const ::modes::node& iceP_n, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNode(iceP_n, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNode(const ::modes::node& iceP_n, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNode(iceP_n, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNode(const ::modes::node& iceP_n, const ::modes::Callback_getAction_getNodePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNode(iceP_n, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNode(const ::modes::node& iceP_n, const ::Ice::Context& context, const ::modes::Callback_getAction_getNodePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNode(iceP_n, context, del, cookie);
    }

    ::modes::node end_getNode(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getNode(const ::modes::node&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::SliceChecksumDict getChecksums(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getChecksums(_iceI_begin_getChecksums(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getChecksums(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getChecksums(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getChecksums(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getChecksums(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getChecksums(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getChecksums(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getChecksums(const ::modes::Callback_getAction_getChecksumsPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getChecksums(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getChecksums(const ::Ice::Context& context, const ::modes::Callback_getAction_getChecksumsPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getChecksums(context, del, cookie);
    }

    ::Ice::SliceChecksumDict end_getChecksums(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getChecksums(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

}

}

namespace modes
{

class actions : public virtual ::Ice::Object
{
public:

    typedef actionsPrx ProxyType;
    typedef actionsPtr PointerType;

    virtual ~actions();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual void printString(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_printString(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int printStringWithRet(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_printStringWithRet(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getnum(::Ice::Int, ::Ice::Int, ::Ice::Int&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getnum(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void compute_async(const ::modes::AMD_actions_computePtr&, ::Ice::Int, ::Ice::Int, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_compute(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const actions& lhs, const actions& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const actions& lhs, const actions& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class base : public virtual ::Ice::Object
{
public:

    typedef basePrx ProxyType;
    typedef basePtr PointerType;

    virtual ~base();

    base()
    {
    }

    explicit base(::Ice::Int iceP_name) :
        name(iceP_name)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int name;
};
static ::Ice::ValueFactoryPtr _iceS_base_init = ::modes::base::ice_factory();

inline bool operator==(const base& lhs, const base& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const base& lhs, const base& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class stu : public ::modes::base
{
public:

    typedef stuPrx ProxyType;
    typedef stuPtr PointerType;

    virtual ~stu();

    stu()
    {
    }

    stu(::Ice::Int iceP_name, ::Ice::Int iceP_num) :
        ::modes::base(iceP_name),
        num(iceP_num)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);

public:

    ::Ice::Int num;
};
static ::Ice::ValueFactoryPtr _iceS_stu_init = ::modes::stu::ice_factory();

inline bool operator==(const stu& lhs, const stu& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const stu& lhs, const stu& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class getAction : public virtual ::Ice::Object
{
public:

    typedef getActionPrx ProxyType;
    typedef getActionPtr PointerType;

    virtual ~getAction();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual ::modes::actionsPrx getactions(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getactions(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::modes::stuPtr getStu(const ::modes::stuPtr&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getStu(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::modes::node getNode(const ::modes::node&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getNode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::SliceChecksumDict getChecksums(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getChecksums(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const getAction& lhs, const getAction& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const getAction& lhs, const getAction& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

}

namespace Ice
{

template<typename S>
struct StreamWriter< ::modes::base, S>
{
    static void write(S* ostr, const ::modes::base& v)
    {
        ostr->write(v.name);
    }
};

template<typename S>
struct StreamReader< ::modes::base, S>
{
    static void read(S* istr, ::modes::base& v)
    {
        istr->read(v.name);
    }
};

template<typename S>
struct StreamWriter< ::modes::stu, S>
{
    static void write(S* ostr, const ::modes::stu& v)
    {
        ostr->write(v.num);
    }
};

template<typename S>
struct StreamReader< ::modes::stu, S>
{
    static void read(S* istr, ::modes::stu& v)
    {
        istr->read(v.num);
    }
};

template<>
struct StreamableTraits< ::modes::node>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::modes::node, S>
{
    static void write(S* ostr, const ::modes::node& v)
    {
        ostr->write(v.n1);
        ostr->write(v.n2);
    }
};

template<typename S>
struct StreamReader< ::modes::node, S>
{
    static void read(S* istr, ::modes::node& v)
    {
        istr->read(v.n1);
        istr->read(v.n2);
    }
};

}

namespace modes
{

template<class T>
class CallbackNC_actions_printString : public Callback_actions_printString_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_actions_printString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_actions_printStringPtr
newCallback_actions_printString(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_actions_printString<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_actions_printStringPtr
newCallback_actions_printString(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_actions_printString<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_actions_printStringPtr
newCallback_actions_printString(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_actions_printString<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_actions_printStringPtr
newCallback_actions_printString(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_actions_printString<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_actions_printString : public Callback_actions_printString_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_actions_printString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_actions_printStringPtr
newCallback_actions_printString(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_actions_printString<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_actions_printStringPtr
newCallback_actions_printString(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_actions_printString<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_actions_printStringPtr
newCallback_actions_printString(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_actions_printString<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_actions_printStringPtr
newCallback_actions_printString(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_actions_printString<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_actions_printStringWithRet : public Callback_actions_printStringWithRet_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_actions_printStringWithRet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::actionsPrx proxy = ::modes::actionsPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_printStringWithRet(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_actions_printStringWithRetPtr
newCallback_actions_printStringWithRet(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_actions_printStringWithRet<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_actions_printStringWithRetPtr
newCallback_actions_printStringWithRet(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_actions_printStringWithRet<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_actions_printStringWithRet : public Callback_actions_printStringWithRet_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_actions_printStringWithRet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::actionsPrx proxy = ::modes::actionsPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_printStringWithRet(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_actions_printStringWithRetPtr
newCallback_actions_printStringWithRet(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_actions_printStringWithRet<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_actions_printStringWithRetPtr
newCallback_actions_printStringWithRet(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_actions_printStringWithRet<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_actions_getnum : public Callback_actions_getnum_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, ::Ice::Int);

    CallbackNC_actions_getnum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::actionsPrx proxy = ::modes::actionsPrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_num;
        bool ret;
        try
        {
            ret = proxy->end_getnum(iceP_num, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_num);
        }
    }

private:

    Response _response;
};

template<class T> Callback_actions_getnumPtr
newCallback_actions_getnum(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_actions_getnum<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_actions_getnumPtr
newCallback_actions_getnum(T* instance, void (T::*cb)(bool, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_actions_getnum<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_actions_getnum : public Callback_actions_getnum_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, ::Ice::Int, const CT&);

    Callback_actions_getnum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::actionsPrx proxy = ::modes::actionsPrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_num;
        bool ret;
        try
        {
            ret = proxy->end_getnum(iceP_num, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_num, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_actions_getnumPtr
newCallback_actions_getnum(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_actions_getnum<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_actions_getnumPtr
newCallback_actions_getnum(T* instance, void (T::*cb)(bool, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_actions_getnum<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_actions_compute : public Callback_actions_compute_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_actions_compute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::actionsPrx proxy = ::modes::actionsPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_compute(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_actions_computePtr
newCallback_actions_compute(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_actions_compute<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_actions_computePtr
newCallback_actions_compute(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_actions_compute<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_actions_compute : public Callback_actions_compute_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_actions_compute(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::actionsPrx proxy = ::modes::actionsPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_compute(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_actions_computePtr
newCallback_actions_compute(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_actions_compute<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_actions_computePtr
newCallback_actions_compute(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_actions_compute<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_getAction_getactions : public Callback_getAction_getactions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::modes::actionsPrx&);

    CallbackNC_getAction_getactions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::getActionPrx proxy = ::modes::getActionPrx::uncheckedCast(result->getProxy());
        ::modes::actionsPrx ret;
        try
        {
            ret = proxy->end_getactions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_getAction_getactionsPtr
newCallback_getAction_getactions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::modes::actionsPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_getAction_getactions<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_getAction_getactionsPtr
newCallback_getAction_getactions(T* instance, void (T::*cb)(const ::modes::actionsPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_getAction_getactions<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_getAction_getactions : public Callback_getAction_getactions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::modes::actionsPrx&, const CT&);

    Callback_getAction_getactions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::getActionPrx proxy = ::modes::getActionPrx::uncheckedCast(result->getProxy());
        ::modes::actionsPrx ret;
        try
        {
            ret = proxy->end_getactions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_getAction_getactionsPtr
newCallback_getAction_getactions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::modes::actionsPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_getAction_getactions<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_getAction_getactionsPtr
newCallback_getAction_getactions(T* instance, void (T::*cb)(const ::modes::actionsPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_getAction_getactions<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_getAction_getStu : public Callback_getAction_getStu_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::modes::stuPtr&);

    CallbackNC_getAction_getStu(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::getActionPrx proxy = ::modes::getActionPrx::uncheckedCast(result->getProxy());
        ::modes::stuPtr ret;
        try
        {
            ret = proxy->end_getStu(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_getAction_getStuPtr
newCallback_getAction_getStu(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::modes::stuPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_getAction_getStu<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_getAction_getStuPtr
newCallback_getAction_getStu(T* instance, void (T::*cb)(const ::modes::stuPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_getAction_getStu<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_getAction_getStu : public Callback_getAction_getStu_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::modes::stuPtr&, const CT&);

    Callback_getAction_getStu(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::getActionPrx proxy = ::modes::getActionPrx::uncheckedCast(result->getProxy());
        ::modes::stuPtr ret;
        try
        {
            ret = proxy->end_getStu(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_getAction_getStuPtr
newCallback_getAction_getStu(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::modes::stuPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_getAction_getStu<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_getAction_getStuPtr
newCallback_getAction_getStu(T* instance, void (T::*cb)(const ::modes::stuPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_getAction_getStu<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_getAction_getNode : public Callback_getAction_getNode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::modes::node&);

    CallbackNC_getAction_getNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::getActionPrx proxy = ::modes::getActionPrx::uncheckedCast(result->getProxy());
        ::modes::node ret;
        try
        {
            ret = proxy->end_getNode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_getAction_getNodePtr
newCallback_getAction_getNode(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::modes::node&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_getAction_getNode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_getAction_getNodePtr
newCallback_getAction_getNode(T* instance, void (T::*cb)(const ::modes::node&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_getAction_getNode<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_getAction_getNode : public Callback_getAction_getNode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::modes::node&, const CT&);

    Callback_getAction_getNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::getActionPrx proxy = ::modes::getActionPrx::uncheckedCast(result->getProxy());
        ::modes::node ret;
        try
        {
            ret = proxy->end_getNode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_getAction_getNodePtr
newCallback_getAction_getNode(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::modes::node&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_getAction_getNode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_getAction_getNodePtr
newCallback_getAction_getNode(T* instance, void (T::*cb)(const ::modes::node&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_getAction_getNode<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_getAction_getChecksums : public Callback_getAction_getChecksums_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::SliceChecksumDict&);

    CallbackNC_getAction_getChecksums(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::getActionPrx proxy = ::modes::getActionPrx::uncheckedCast(result->getProxy());
        ::Ice::SliceChecksumDict ret;
        try
        {
            ret = proxy->end_getChecksums(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_getAction_getChecksumsPtr
newCallback_getAction_getChecksums(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::SliceChecksumDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_getAction_getChecksums<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_getAction_getChecksumsPtr
newCallback_getAction_getChecksums(T* instance, void (T::*cb)(const ::Ice::SliceChecksumDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_getAction_getChecksums<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_getAction_getChecksums : public Callback_getAction_getChecksums_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::SliceChecksumDict&, const CT&);

    Callback_getAction_getChecksums(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::modes::getActionPrx proxy = ::modes::getActionPrx::uncheckedCast(result->getProxy());
        ::Ice::SliceChecksumDict ret;
        try
        {
            ret = proxy->end_getChecksums(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_getAction_getChecksumsPtr
newCallback_getAction_getChecksums(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::SliceChecksumDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_getAction_getChecksums<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_getAction_getChecksumsPtr
newCallback_getAction_getChecksums(T* instance, void (T::*cb)(const ::Ice::SliceChecksumDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_getAction_getChecksums<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
